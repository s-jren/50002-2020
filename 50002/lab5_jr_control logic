.include "nominal.jsim"
.include "stdcell.jsim"
.include "lab5ctl.jsim"

*control logic

.subckt ctl reset id[31:26] ra2sel bsel alufn[5:0] wdsel[1:0] werf moe wr

Xctl vdd 0 0 id[31:26] // one read port
+ pcsel[2:0] wasel asel ra2sel bsel alufn[5:0] wdsel[1:0] werf moe xwr
+ $memory width=18 nlocations=64 contents=(
+ 0b000000000000000000 // opcode=0b000000
+ 0b000000000000000000 // opcode=0b000001
+ 0b000000000000000000 // 2
+ 0b000000000000000000 // 3
+ 0b000000000000000000 // 4
+ 0b000000000000000000 // 5
+ 0b000000000000000000 // 6
+ 0b000000000000000000 // 7
+ 0b000000000000000000 // 8
+ 0b000000000000000000 // 9
+ 0b000000000000000000 // 10
+ 0b000000000000000000 // 11
+ 0b000000000000000000 // 12
+ 0b000000000000000000 // 13
+ 0b000000000000000000 // 14
+ 0b000000000000000000 // 15
+ 0b000000000000000000 // 16
+ 0b000000000000000000 // 17
+ 0b000000000000000000 // 18
+ 0b000000000000000000 // 19
+ 0b000000000000000000 // 20
+ 0b000000000000000000 // 21
+ 0b000000000000000000 // 22
+ 0b000000000000000000 // 23
+ 0b000000100000010110 // 24 LD 0x18
+ 0b000001100000000001 // 25 ST 
+ 0b000000000000000000 // 26
+ 0b010000000000000100 // 27 JMP
+ 0b000000000000000000 // 28
+ 0b000000000000000100 // 29 BEQ not branching by default
+ 0b001000000000000100 // 30 BNE branching by default
+ 0b000010001101010110 // 31 LDR 
+ 0b000000000000001100 // 32 ADD
+ 0b000000000000101100 // 33 SUB
+ 0b011100000000000100 // 34 MUL - 
+ 0b011100000000000100 // 35 DIV - 
+ 0b000000011001101100 // 36 CMPEQ
+ 0b000000011010101100 // 37 CMPLT
+ 0b000000011011101100 // 38 CMPLE
+ 0b000000000000000000 // 39
+ 0b000000001100001100 // 40 AND
+ 0b000000001111001100 // 41 OR
+ 0b000000001011001100 // 42 XOR
+ 0b000000000000000000 // 43
+ 0b000000010000001100 // 44 SHL
+ 0b000000010000101100 // 45 SHR
+ 0b000000010001101100 // 46 SHA
+ 0b000000000000000000 // 47
+ 0b000000100000001100 // 48 ADDC
+ 0b000000100000101100 // 49 SUBC
+ 0b011100000000000100 // 50 MULC - 
+ 0b011100000000000100 // 51 DIVC -
+ 0b000000111001101100 // 52 CMPEQC
+ 0b000000111010101100 // 53 CMPLTC
+ 0b000000111011101100 // 54 CMPLEC
+ 0b000000000000000000 // 55
+ 0b000000101100001100 // 56 ANDC
+ 0b000000101111001100 // 57 ORC
+ 0b000000101011001100 // 58 XORC
+ 0b000000000000000000 // 59
+ 0b000000110000001100 // 60 SHLC
+ 0b000000110000101100 // 61 SHRC
+ 0b000000110001101100 // 62 SRAC
+ 0b000000000000000000 // 63
+ )

*WR = 0 when reset = 1
Xresetmux reset xwr 0 wr mux2

*check for BEQ OPCODE 011101
*Xinv_id31 id31 id31_inv inverter
*Xinv_id27 id27 id27_inv inverter
*Xand4_BEQ id31_inv id30 id29 id28 and4_BEQout and4
*XisBEQ and4_BEQout id27_inv id26 is_BEQ and3

*check for BNE OPCODE 011110
*Xinv_id26 id27 id27_inv inverter
*Xand4_BNE id31_inv id30 id29 id28 and4_BNEout and4
*XisBNE and4_BNEout id27 id26_inv is_BNE and3

*.connect z 0 

*XPSEL BEQ postprocessing 
*Xz_BEQmux z#3 xpcsel[2:0] 0#2 vdd pscel_beq[2:0] mux2

*XPSEL BNE postprocessing 
*Xz_BNEmux z#3 xpcsel[2:0] 0#3 pscel_bne[2:0] mux2 

*PCSEL overall postprocessing
*.connect is_BEQ muxsel[0]
*.connect is_BNE muxsel[1]
*Xpcselmux muxsel[0:1]#3 xpsel[2:0] pscel_beq[2:0] 
*pcsel_bne[2:0] 0#3 pcsel[2:0] mux4 


.ends


